msgid ""
msgstr "Project-Id-Version: Game v4.23.0-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-05\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.L2PsetIntro
msgid "Pset 2 NOT YET READY"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "Did you end up using `huv`?\n"
"And then `specialize`ing it with `u` and `v` replaced, respectively, by `x` and `y`?\n"
"Or did you think of going via the more direct route:\n"
"`have hxy : (x + y) ^ 2 = (x ^ 2 + y ^ 2) + 2 * (x * y) := by ring_nf`?"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "The `linarith` tactic, with syntax `linarith [h‚ÇÅ, h‚ÇÇ]`, can solve goals that are linear arithmetic combinations of hypotheses `h‚ÇÅ, h‚ÇÇ` involving `‚â§`, `<`, `=` with addition and multiplication by constants."
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
msgid "Prove that if `c` is a nonzero constant and `lim a = L`, and `b (n) = c * a (n)` for all `n`, then `lim b = c * L`."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The `use` tactic provides a specific value to prove an existence statement."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Write `specialize hf t` to apply the universal statement to the specific value t."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "You can't use `abs_mul` just yet, because you don't have a product of things inside the absolute values! So first factor out the 2: `have factor : 2 * a n - 2 * L = 2 * (a n - L) := by ring_nf`"
msgstr ""

#: Game
msgid "Learn real analysis through the historical crises that forced mathematicians to rebuild calculus from the ground up in the 19th century."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "Write `choose c hc using h`, then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "# üéâ Brilliant Work! üéâ\n"
"\n"
"You've mastered your first true theorem of analysis! Let's celebrate what you accomplished and understand the deeper patterns.\n"
"\n"
"**What you just proved:**\n"
"If a sequence converges to a limit, then any constant multiple of that sequence converges to the constant multiple of the limit. In factory terms: 'If I can meet quality standards, I can also meet those same standards when scaling my output‚ÄîI just need to be more precise with my inputs!'\n"
"\n"
"**The Elegant Strategy:**\n"
"Your proof used the **inverse scaling** principle:\n"
"1. **Tolerance inversion**: To achieve tolerance Œµ for doubled output, demand tolerance Œµ/2 for original input\n"
"2. **Algebraic factoring**: `2 * a n - 2 * L = 2 * (a n - L)` revealed the structure\n"
"3. **Absolute value scaling**: `|2 * x| = |2| * |x|`, followed by `norm_num`, converted the factored form to the needed bound\n"
"4. **Linear arithmetic**: The final `linarith [hN]` combined `2 * |a n - L| < 2 * (Œµ / 2) = Œµ`\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Let's again step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If a sequence of real numbers converges to some limit, then the sequence formed by doubling each term converges to double the original limit.\n"
"\n"
"**Proof:** Suppose sequence $a_n$ converges to $L$, and we want to show that $b_n = 2 \\cdot a_n$ converges to $2L$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|b_n - 2L| < \\varepsilon$.\n"
"\n"
"Here's the key insight: Since $a_n$ converges to $L$, we can make $|a_n - L|$ arbitrarily small. Specifically, we can find an $N$ such that $|a_n - L| < \\varepsilon/2$ for all $n \\geq N$.\n"
"\n"
"Now, for any $n \\geq N$:\n"
"$$|b_n - 2L| = |2a_n - 2L| = |2(a_n - L)| = 2|a_n - L| < 2 \\cdot \\frac{\\varepsilon}{2} = \\varepsilon$$\n"
"\n"
"Therefore, $b_n$ converges to $2L$, completing the proof.\n"
"**QED**\n"
"\n"
"So what do you think? Do you prefer the natural langauge version, or the formal version? (It's a real question! Please tell me.)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "Big Boss: The Ultimate Tactic Challenge"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "# Problem 2\n"
"\n"
"In this problem you are asked to show that there is some `c` so that `(x + y) ^ 2 = c`, given that\n"
"`x * y = 1` and `x ^ 2 + y ^ 2 = 2`. Of course you can say `use (x + y) ^ 2`, but that's obviously\n"
"not the point; the value of `c` that you choose should *not* involve `x` and `y`!\n"
"\n"
"You will likely have a hard time solving this problem as is.\n"
"You surely can work out what value of\n"
"`c` you need. But if you try\n"
"`ring_nf`, you won't have control over\n"
"how the \"normal form\" chooses to\n"
"express things. In fact, the\n"
"left-hand side, `(x + y) ^ 2` will\n"
"turn into `x * y * 2 + x ^ 2 + y ^ 2`,\n"
"which is parsed in this order:\n"
"\n"
"`(((x * y) * 2) + x ^ 2) + y ^ 2`\n"
"\n"
"This means that you *will* be able to\n"
"`rewrite [h2]` successfully,\n"
"but then you will *not* be able to rewrite by `h1`, because the (invisible) parentheses  go the wrong way. (Hint: If you want to know how things are grouped but don't see parentheses, you can hover your cursor over the text in the Goal State, and Lean will show you the groupings. Try it!)\n"
"\n"
"Now, in natural language, there are times when you might want to\n"
"record an auxiliary fact: \"let's\n"
"*have* the fact that such and such ...\". The Lean\n"
"syntax for this is as follows:\n"
"\n"
"`have NewFactName (Assumptions) : Conclusion := by Proof`\n"
"\n"
"That is, you first write `have`; then give\n"
"the new hypothesis a name; then include any\n"
"assumptions, like `(x : ‚Ñù)`, meaning, `x`\n"
"is a real number, etc (the symbol `‚Ñù` is written with a backslash, then capital `R`, then space); then you put a colon,\n"
"and then state the conclusion; then you\n"
"put a colon-equals and the word `by`; and finally you give the proof.\n"
"\n"
"For example, if you wanted to declare\n"
"the new fact that, say, for any real `u` and `v`,\n"
"\n"
"`(u + v) ^ 2 = (u ^ 2 + v ^ 2) + 2 * (u * v)`\n"
"\n"
"and you wanted to call this fact `huv` (a hypothesis on `u` and `v`),\n"
"and you wanted to prove this fact by\n"
"invoking the ring normal form tactic,\n"
" then you would give Lean the command:\n"
"\n"
"`have huv (u v : ‚Ñù), (u ^ 2 + v ^ 2) + 2 * (u * v) := by ring_nf`\n"
"\n"
"This will add to your list of hypotheses\n"
"the fact: `huv : ‚àÄ (u v : ‚Ñù), (u ^ 2 + v ^ 2) + 2 * (u * v)`.\n"
"\n"
"Something like this (if not exactly this)\n"
"will be useful to you in solving this problem."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# üéâ VICTORY! üéâ\n"
"\n"
"You've defeated the Big Boss and mastered all the fundamental tactics of mathematical reasoning!\n"
"\n"
"**Let's see what you just accomplished:**\n"
"\n"
"1. **`choose a ha using h_existential`** - Extracted the witness `a` and fact that `f (a) = 3` from the hypothesis\n"
"2. **`use a`** - Chose `a` as your witness for the existence statement in the goal\n"
"3. **`intro y hy`** - Handled the universal quantifier \"for all y > 0\" in the goal\n"
"4. **`specialize h_universal y hy`** - Applied the universal property to your specific value in the hypothesis\n"
"5. **`rewrite [h_universal]`** - Used the specialized fact to rewrite the goal\n"
"6. **`rewrite [ha]`** - Used the original fact that `f (a) = 3` to also rewrite the goal\n"
"7. **`ring_nf`** - Verified finally that `(f y + 9) ^ 2 = (f y + 3 ^ 2) ^ 2`\n"
"\n"
"You've just completed a genuinely sophisticated mathematical argument! This kind of multi-step reasoning, combining existence statements, universal properties, and algebraic manipulation, is exactly what you'll encounter throughout real analysis.\n"
"\n"
"**You are now ready to begin your journey to rigorous calculus!**\n"
"\n"
"Welcome to the Introduction to Formal Real Analysis. üéì\n"
"\n"
"**Epilogue**\n"
"\n"
"Before we continue with more Real Analysis and more Lean, let‚Äôs pause to note a few interesting things about working formally.\n"
"Using a theorem prover interactively is (I hope) tremendously fun and (I hope) leads to rapid gains, immediate feedback, and clarity of thought.\n"
"\n"
"Imagine trying to learn chess by just reading through algebraic notation - 1.e4 e5 2.Nf3 Nf6 3.Bb5 a6 - sure, all the information is technically there, but isn't it so much easier to learn by actually looking at a chess board and seeing how the position changes after each move? In mathematics, it would be extraordinarily tedious to manually write on the blackboard the entire goal state after every move, keeping track of all the hypotheses and their relationships by hand. A theorem prover does this bookkeeping for you automatically, letting you focus on the mathematical content rather than the clerical work.\n"
"\n"
"But! This is, as we've already noted, a double-edged sword. We still want to train our brains to \"see\" a mental model of the goal state evolving - good chess players can visualize many moves ahead precisely because they've learned to maintain multiple mental game boards simultaneously. But until you develop that skill, and even after you have it, there's immense value in being able to instantly generate the current \"game board\" of your proof state. The immediate feedback helps you understand the consequences of each logical move, building the very intuition that will eventually let you work more independently. It's the difference between learning to navigate by always checking your GPS versus eventually developing an internal sense of direction - both have their place, and the former helps develop the latter."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L03_SumOfSeqs
msgid "For two sequences `a b : ‚Ñï ‚Üí ‚Ñù` and real numbers `L M : ‚Ñù`, with the hypotheses that `SeqLim a L` and `SeqLim b M`, the theorem `SumLim` says that if\n"
"there is a third sequence `c : ‚Ñï ‚Üí ‚Ñù` so that for all `n`, `c n = a n + b n` (that is, `c` is the sum of the sequences), then `SeqLim c (L + M)` holds."
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
msgid "# Problem 4\n"
"\n"
"This problem looks very similar to the previous one, but without a few hints, it\n"
"may cause great difficulty. The issue is that, last time, you likely called `specialize h1 0`, and turned `h1` into:\n"
"\n"
"`h1 : g (0 + 1) = g (0) + 3`\n"
"\n"
"If you do that now, the original `h1` will be *gone*, and you won't have a way of accessing it *again* to bootstrap from `g (1)` to `g (2)`. So what should you do?\n"
"\n"
"Observe that `have` can perform the same\n"
"role as `specialize` (and much more)! Try starting your solution with:\n"
"\n"
"`have h3 : g (0 + 1) = g (0) + 3 := by apply h1 0`\n"
"\n"
"This will not affect the original statement\n"
"of `h1`, but will instead add a *new* hypothesis, `h3`, which amounts to the\n"
"desired fact that `g (0 + 1) = g (0) + 3`.\n"
"Notice what's happening in the proof: `h1` says: for all `x`, `g (x + 1) = g (x) + 3`.\n"
"So `h1` is really a *function* whose input\n"
"is a real number `x`, and whose output is a\n"
"*proof* of the fact that, for this value of `x`, `g (x + 1) = g (x) + 3` holds. So when\n"
"we feed `0` into `h1`, it has the same effect\n"
"as it did when we `specialize`d, thus giving a proof of\n"
" exactly what was claimed in the `have` statement.\n"
"\n"
"Now you should be able to solve this problem."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The `rfl` tactic proves goals of the form `A = A` where both sides are *identical*."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "The `linarith` tactic won't work\n"
"yet, because it'll get stuck on that `|2|`; do you remember what to do\n"
"to normalize the numerical value to just `2`?"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L03_SumOfSeqs
msgid "Prove that the sum of two convergent sequences converges to the sum of their limits.\n"
"This is the mathematician's version of 'if two factories each meet their quality standards, their combined output will too!'"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The intro tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Great! You've learned the `specialize` tactic.\n"
"\n"
"Notice what happened:\n"
"1. Initially, `hf : ‚àÄ x > 0, f (x) = x^2` was a universal statement\n"
"2. `specialize hf t` transformed it into `hf : t > 0 ‚Üí f (t) = t ^ 2`\n"
"3. Another `specialize` command, namely `specialize hf t_pos` turned the\n"
"hypothesis `hf` into `hf : f (t) = t ^ 2`\n"
"4. And finally, `apply hf` worked because the hypothesis matched the goal.\n"
"\n"
"The pattern is:\n"
"- `intro` when you have `‚àÄ` in the goal (\"introduce an arbitrary term...\")\n"
"- `specialize` when you have `‚àÄ` in a hypothesis (\"apply the hypothesis to specific value...\")\n"
"\n"
"This is fundamental in real analysis when working with:\n"
"- Function properties that hold \"for all x\"\n"
"- Limit definitions involving \"for all Œµ > 0\"\n"
"- Continuity statements\n"
"\n"
"Last lesson in Lecture 1 coming up."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Excellent! You've learned the `intro` tactic for universal statements.\n"
"\n"
"Notice what happened:\n"
"1. `intro Œµ` introduced the arbitrary real number Œµ\n"
"2. `intro hŒµ` introduced the hypothesis `hŒµ : Œµ > 0`\n"
"3. The goal became `(Œµ + 1)^2 = (Œµ + 1)^2`\n"
"4. `rfl` solved the goal, by the reflexive property of the equals sign.\n"
"\n"
"You might have noticed something interesting: we used `intro` in two seemingly different ways -- first to introduce an \"Object\" (the real number `Œµ`), and second to introduce an \"Assumption\" or hypothesis (that `Œµ > 0`). In Lean's underlying logic (\"dependent type theory\"), there's actually a deep unity here that mathematicians call the *Curry-Howard correspondence*: propositions are \"Types\", and proofs are \"Terms\" of those Types. This means that introducing a hypothesis is really just introducing a term of a certain type, just like introducing a variable.\n"
"\n"
"But here's an even more mind-bending perspective: our entire Statement is really a *function*! Its inputs are first an `Œµ : ‚Ñù`, then a proof that `Œµ > 0`, and its output is a proof that `(Œµ + 1)^2 = (Œµ + 1)^2`. When we write `intro Œµ` and `intro h`, we're literally defining this function by saying \"given these inputs, here's how to compute the output.\" In this view, all of mathematics -- from the simplest definitions to proofs of the deepest theorems -- is secretly just **functions** transforming inputs into outputs!\n"
"\n"
"This beautiful connection between logic and computation underlies much of modern proof assistants, though we won't dive into the details in this course -- it's perfectly fine if you didn't follow the last two paragraphs! For now, just appreciate that `intro` works uniformly whether you're introducing mathematical objects or logical assumptions, and that every proof you write is secretly a program!\n"
"\n"
"The `intro` tactic is absolutely crucial in real analysis. You'll use it constantly to:\n"
"- Handle \"for all Œµ > 0\" statements in limit definitions\n"
"- Introduce arbitrary points in domain/range proofs\n"
"- Work with function definitions\n"
"\n"
"This pattern of `intro` followed by algebraic manipulation is everywhere in analysis!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# Level 1: The Main Definition\n"
"\n"
"Our first step to making Newton's argument rigorous is\n"
"to spell out *exactly* what we mean by a sequence\n"
"$a_n$ converging. It will take a little work to build up to the definition, and more importantly, *why*\n"
"that might seem like a reasonable definition to have.\n"
"\n"
"But first: for some reason (likely Euler is to blame), mathematics has *two* completely different conventions for how to write functions. For general functions $f : \\mathbb R \\to\\mathbb R$,\n"
"we write $f(x)$, with parentheses. But when work with sequences, $a_n$, meaning,\n"
"$a_0, a_1, a_2, \\dots$, we bizarely switch instead to subscripts.\n"
"Why? Historical accident.\n"
"A sequence is nothing but a function whose \"domain\" (that is, the set of\n"
"inputs to the function) is the natural numbers; so we will break\n"
"with tradition and unify the two conventions, henceforth writing\n"
"$a : \\mathbb N \\to \\mathbb R$ for sequences of real numbers, $a (0), a (1),\n"
"a (2), \\dots$.\n"
"\n"
"Now, the definition that mathematicians eventually came up with\n"
"for what it means for a sequence to converge, was so intricate (at least\n"
"at first sight) that it had to be invented *twice*!\n"
"The eventual formulation crystallized through the work of Karl Weierstrass in the 1860s, who transformed analysis from an intuitive art into a rigorous science. However, the seeds of this idea appeared much earlier in the work of Bernard Bolzano. In the 1810s and 1820s, Bolzano was developing remarkably modern ideas about continuity and limits, but he was too far ahead of his time for the mathematical community to accept these abstract concepts.\n"
"Only by Weierstrass's time -- a half-century later -- did these ideas catch on.\n"
"\n"
"Without further ado, here it is:\n"
"\n"
"Given a sequence `a : ‚Ñï ‚Üí ‚Ñù` and a real number `L : ‚Ñù`, we\n"
"write `lim a = L` and\n"
"say that the sequence `a` **converges** to `L`,\n"
" if:\n"
"\n"
"For every `Œµ > 0`, there exists `N : ‚Ñï` such that, for all `n ‚â• N`, we have `|a (n) - L| < Œµ`.\n"
"\n"
"\n"
"This definition is probably not the first, or second, or tenth thing you might've come up with.\n"
"But over time, I hope you'll come to see that it\n"
" embodies a beautiful negotiation between precision and effort.\n"
"\n"
" I like to think of it as a conversation between an Engineer and a Machinist. The Engineer arrives with specifications: 'We're going to make this widget, and I need its length to be 1 foot, with an error tolerance\n"
" of 1/100 of an inch'. The Machinist replies: 'Sure, I can do that, but I'll have to run my special equipment for at least 10 hours to guarantee that tolerance.' The Enginner\n"
" replies: 'I'm sorry, I misspoke, can we change the tolerance\n"
" to 1/1000 of an inch?' The Machinist replies: 'Oof, yeah we can do it, but it'll cost ya. I'll need at least 40 hours of operation, but after that, I'll guarantee it.'\n"
"\n"
"As long as this conversation can continue regardless of *whatever* tolerance `Œµ > 0` the Engineer requires, with the Machinist\n"
"always being able to reply with a finite minimum number of hours `N`,\n"
"after which the tolerance will be achieved, we can say\n"
"that the equipment **converges**.\n"
"\n"
"Now let's read Weierstrauss's (or is it Bolzano's?) definition again. We have some process\n"
"that at time `n` returns a reading `a (n)` (think: widget length). Our ultimate goal is to make the length `L`. If\n"
"for any tolerance `Œµ > 0`, no matter how small, there will always exist some minimum\n"
"time `N`, so that, for any future time, `n ‚â• N`,\n"
"we are guaranteed to be within that tolerance, `|a (n) - L| < Œµ`, that's exactly the condition under which we'll\n"
"say that the sequence `a (n)` **converges** to `L`.\n"
"\n"
"[![A Sequence Converging](images/SeqLim.jpg)](https://en.wikipedia.org/wiki/Limit_of_a_sequence)\n"
"\n"
"What makes this definition so powerful is its universality. The Machinist is essentially promising: 'Give me *any* tolerance requirement, no matter how stringent, and I can meet it -- though I might need more resources (larger `N`) for tighter specifications.'\n"
"\n"
"\n"
"Notice something else about the definition: It makes no mention of something happening \"eventually\", or \"at infinity\" or any other wishy-washy squirm words. We have traded the ambiguity of speaking about infinity for the precision of existential and universal quantifiers. No more hand-waving about what happens \"as `n` gets large\" - instead, we have a concrete challenge: given *any* tolerance `Œµ`, can you find a specific threshold `N`? *That* idea was the key breakthrough that allowed Calculus to enter the realm of rigorous mathematics.\n"
"\n"
"In Lean, the definition is written like so:\n"
"\n"
"`def SeqLim (a : ‚Ñï ‚Üí ‚Ñù) (L : ‚Ñù) : Prop :=\n"
"  ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, |a n - L| < Œµ`\n"
"\n"
"This syntax should be familiar from the `have` tactic you already know and love.\n"
"The special symbol `def` (instead of `have`) means that we're about to define something, and\n"
"`SeqLim` is its name (for squence limit, of course; but we could have called it whatever we want). Then our assumptions are a sequence `a : ‚Ñï ‚Üí ‚Ñù` and\n"
"some real number `L : ‚Ñù`. Then after the colon `:` goes our output, which in this case is `Prop`, that is, a statement (proposition) that can be true or false. So `SeqLim` is really a function that takes a sequence and hypothetical limiting value, and returns true or false based on whether\n"
"the condition is satisfied. Then comes a colon-equals `:=`, after which the\n"
"exact condition to be tested is specified. And the condition is what we already said, for all epsilon, yadda yadda. The big difference is that you can write `have` inside a proof, but you can't write `def` inside a proof;\n"
"`def` is reserved for making global definitions that\n"
"can be referenced forever once they're introduced.\n"
"Notice that on the right hand side, the list\n"
"of Definitions now includes `SeqLim`, and, as usual,\n"
"if you forget what it means, you can click on it for a reminder.\n"
"\n"
"Let's try out the definition in practice!\n"
"\n"
"**Your Task**\n"
"\n"
"Prove that the constant sequence converges to the same constant.\n"
"That is, suppose that you have a sequence `a : ‚Ñï ‚Üí ‚Ñù`, and there's a real number\n"
"`L`, and a hypothesis that, for all values of `n`, we have  `a (n) = L`; then prove that `a` does converge, and converges to `L`. This is the simplest possible case: if our 'factory' always produces the exact target value `L`, then we can meet any tolerance requirement immediately!\n"
"\n"
"You may find useful a new tactic called `change`. It allows you to replace a goal (or hypothesis) by\n"
"something that is definitionally equal to it. In our example here,\n"
"You will see the goal as `SeqLim a L`. What are you supposed to do with that,\n"
"how can you make progress? Well, if you remember how `SeqLim` is defined,\n"
"then you can replace the goal with the definition, by writing\n"
"\n"
"`change ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, |a n - L| < Œµ`\n"
"\n"
"Lean will then change the goal to its definition.\n"
"Remember that `Œµ`, `N`, and `n` are all dummy variables\n"
"here, so you can have some fun:\n"
"\n"
"`change ‚àÄ Alice > 0, ‚àÉ Bob : ‚Ñï, ‚àÄ blah ‚â• Bob, |a blah - L| < Alice`\n"
"\n"
"This may come in handy later. (Not Alice and Bob *per se*, but the ability to give better names for dummy variables, so as not to clash with already existing variable names...)\n"
"\n"
"**‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CAUTION ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è** Remember how Lean *must* have space after a function name, it won't accept `f(x)` but instead requires `f (x)`? Well... it's the other way around for absolute\n"
"values. Lean won't accept a space after an absolute value.\n"
"So if you write `| a n - L|`, you'll get an error message.\n"
"Same with `|a n - L |` -- the space at the end is the problem. Sorry! I didn't write the syntax.\n"
"\n"
"**Normalizing Numerical Values**: And one last tactic you might also find useful is `norm_num` (for normalizing numerical values); it evaluates numerical expressions and proves equalities/inequalities involving concrete numbers. For example, if you're stuck with an `|0|` at some point,\n"
"and you want to convert it to plain old `0`, try calling `norm_num`.\n"
"\n"
"Ok, get to it!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Start by unfolding the definition: `change ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, |b n - 2 * L| < Œµ`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Write `rfl` since we're proving that something equals itself."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Try starting with `change ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, |a n - L| < Œµ`"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "And finally, this is where the powerful `linarith` tactic can take over. Remember to feed it (in brackets) the hypothesis (or hypotheses, separated by commas) which you want to manipulate to turn into the Goal."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The `intro` tactic introduces variables and hypotheses from ‚àÄ statements or implications."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L03_SumOfSeqs
msgid "# Lecture 2 **Big Boss**: Adding Convergent Sequences\n"
"\n"
"Now that we've had some experience with the definition of convergence, let's tackle this world's Big Boss. One of the most fundamental ideas in analysis is that 'nice operations preserve convergence.' If two sequences each converge, then their sum also converges, and converges to the sum of their limits.\n"
"\n"
"This might seem obvious at first -- after all, if $a(n)$ is getting close to $L$ and $b(n)$ is getting close to $M$, shouldn't $a(n) + b(n)$ get close to $L + M$? While the intuition is correct, making this rigorous requires some clever maneuvering with our epsilon-N definition.\n"
"\n"
"**Lecture 2 Big Boss**\n"
"Here's the key insight: if an engineer demands that our combined output be within $\\varepsilon$ of the target $L + M$, we can't just demand that each factory independently meet the full tolerance $\\varepsilon$. Instead, we need to be clever about how we allocate our 'tolerance budget.'\n"
"\n"
"Think of it this way: if the first factory can guarantee its output is within $\\varepsilon/2$ of $L$, and the second factory can guarantee its output is within $\\varepsilon/2$ of $M$, then by the triangle inequality, their sum will be within $\\varepsilon$ of $L + M$. This is the heart of the proof!\n"
"\n"
"## The Mathematical Setup\n"
"\n"
"Suppose we have:\n"
"- A sequence $a : \\mathbb{N} \\to \\mathbb{R}$ that converges to $L$\n"
"- A sequence $b : \\mathbb{N} \\to \\mathbb{R}$ that converges to $M$\n"
"- A sequence $c : \\mathbb{N} \\to \\mathbb{R}$ with the property that $c(n) = a(n) + b(n)$ for all $n$\n"
"\n"
"We want to prove that $c$ converges to $L + M$.\n"
"\n"
"## New Tool\n"
"\n"
"You'll only need one new theorem:\n"
"\n"
"**The triangle inequality**: The theorem `abs_add` states that `|x + y| ‚â§ |x| + |y|` for any real numbers `x` and `y`. This is crucial for our tolerance-splitting strategy.\n"
"Again, when you want to use it in practice, you can always add\n"
"a new hypothesis:\n"
"\n"
"`have NewInequality : |Something + SomethingElse| ‚â§\n"
"|Something| + |SomethingElse| :=\n"
"by apply abs_add`\n"
"\n"
"and then `rewrite [NewInequality]`.\n"
"\n"
"## Your Strategic Approach\n"
"\n"
"- Start by unfolding the definitions of `SeqLim` in the Goal and hypotheses. I recommend you give your dummy variables different names, so as not to get confused later.\n"
"- Given any `Œµ > 0`, use the convergence of `a` to get an `Na` that works for `Œµ / 2`.\n"
"- Similarly, use the convergence of `b` to get an `Nb` that works for `Œµ / 2`\n"
"- You might think that it would be a good idea at this point to `use max Na Nb`, that is, take the larger of the two for `N`. But we don't care how big `N` is! Can you\n"
"think of another way to achieve the same objective? (Hint:\n"
" I haven't told you how to use the `max` function, but I bet you can come up with another function for which you already have everything you need at your disposal...)\n"
"- Use the triangle inequality to combine the two half-tolerances\n"
"\n"
"This proof embodies a fundamental principle in analysis: when dealing with sums, we often need to 'divide and conquer' by splitting our error tolerance between the components."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Write `ring_nf` to expand and simplify both sides algebraically."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Prove that constant multiples of convergent sequences converge to the constant multiple of the limit.\n"
"This is the Machinist's response to scaling demands: 'If you want double the output with the same tolerance, I need half the tolerance on the original process!'"
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
msgid "Problem 3"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Prove that the constant sequence converges to its constant value.\n"
"This is the Machinist's dream scenario: we're already producing exactly what's required!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "Lecture 2: Newton's Computation of œÄ"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "**BIG BOSS LEVEL**: This problem requires all the tactics you've learned!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "For any real numbers `x` and `y`, we have `|x * y| = |x| * |y|`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The `specialize` tactic applies a universal statement in a hypothesis to a specific value."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L03_SumOfSeqs
msgid "# üéâ Outstanding! üéâ\n"
"\n"
"You've just proven one of the fundamental theorems of analysis! Let's celebrate what you accomplished and understand why this result is so powerful.\n"
"\n"
"**Why This Matters:**\n"
"This theorem and others like it are the foundation for all of calculus! Every time we differentiate or integrate a sum, we're implicitly using arguments of this kind.\n"
"\n"
"**The Deeper Insight:**\n"
"Notice how the proof required more than just intuition. The 'obvious' fact that sums of convergent sequences converge needed careful epsilon management. This is the hallmark of rigorous analysis: making intuitive ideas completely precise.\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Yet again, let's step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If two sequences of real numbers converge to their respective limits, then the sequence formed by adding corresponding terms also converges, and its limit is the sum of the original limits.\n"
"\n"
"**Proof:** Suppose sequences $a(n)$ and $b(n)$ converge to $L$ and $M$ respectively, and we want to show that $c(n) = a(n) + b(n)$ converges to $L + M$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|c(n) - (L + M)| < \\varepsilon$.\n"
"\n"
"Since $a(n)$ converges to $L$, we can find $N_1$ such that $|a(n) - L| < \\varepsilon/2$ for all $n \\geq N_1$.\n"
"Since $b(n)$ converges to $M$, we can find $N_2$ such that $|b(n) - M| < \\varepsilon/2$ for all $n \\geq N_2$.\n"
"\n"
"Let $N = N_1 + N_2$ (any number that's at least as large as both $N_1$ and $N_2$ would work). Then for any $n \\geq N$:\n"
"\n"
"$$|c(n) - (L + M)| = |(a(n) + b(n)) - (L + M)| = |(a(n) - L) + (b(n) - M)|$$\n"
"\n"
"By the triangle inequality, this is at most:\n"
"$$|a(n) - L| + |b(n) - M| < \\frac{\\varepsilon}{2} + \\frac{\\varepsilon}{2} = \\varepsilon$$\n"
"\n"
"Therefore, $c(n)$ converges to $L + M$. **QED**"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "If there exists a point where f equals 2, then there exists a point where f¬≤ equals 4."
msgstr ""

#: Game.Levels.L2Pset.L2Pset2
msgid "# Problem 2"
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
msgid "# Problem 3\n"
"\n"
"You've just learned to add any necessary\n"
"auxiliary\n"
"facts to the list of hypotheses via the\n"
"`have` tactic.\n"
"In this problem,\n"
"you might find the following new idea useful.\n"
"\n"
"You already know that if you\n"
"have a hypothesis `h : X = Y`, and the Goal\n"
"contains `X`, then if you `rewrite [h]`,\n"
"then any instances of `X` in the goal\n"
"get replaced by `Y`.\n"
"But what if you have another hypothesis `h2`,\n"
"and you want to replace `X`'s in `h2` by `Y`s, what should you do then?\n"
"Elementary, my dear Watson!\n"
"You simply type:\n"
"\n"
"`rewrite [h] at h2`.\n"
"\n"
"So the syntax is `rewrite [h]` as before, then\n"
"the word `at`, and finally the name of the\n"
"hypothesis where you want the rewriting to happen.\n"
"Similarly, you can say `ring_nf at h2`,\n"
"and any algebra in hypothesis `h2` will be put into normal form.\n"
"\n"
"Now you should be able to solve this problem!"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "Pset 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Now write `specialize hf t_pos` feed in the proof that `t > 0`; then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `change` tactic changes a goal to something definitionally equal to it. If the definition of `X` is `Y`, that is, `X := Y`, and the Goal is `X`, you can write `change Y` and the Goal will change to `Y`. You can also\n"
"do this at a hypothesis; if you have a hypothesis `h : X`, you can write `change Y at h`, and `h` will change to `h : Y`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Perfect! You've completed your first Lean proof involving real numbers.\n"
"\n"
"Remember: the `apply` tactic is used when you have what you need to prove the goal. Look at the top right: your list of tactics now includes `apply`, and if you forget how it works or what it does, just click on it for a reminder."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# The Final Challenge\n"
"\n"
"Congratulations! You've learned many fundamental tactics for mathematical reasoning in Lean:\n"
"- `apply hypothesisName` for when a hypothesis matches the goal\n"
"- `rfl` for reflexivity (proving `X = X`)\n"
"- `rewrite [hypothesisName]` for rewriting using equalities\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for providing witnesses to existence statements in goals\n"
"- `intro` for handling universal quantifiers in goals\n"
"- `specialize` for applying universal statements to specific values in hypotheses\n"
"- `choose value hypothesisOnValue using ExistentialHypothesis` for extracting information from existence statements in hypotheses\n"
"\n"
"Here's a little \"Universal/Existential Quantifier Cheat Sheet\":\n"
"\n"
"|           | ‚àÄ        | ‚àÉ      |\n"
"|-----------|----------|--------|\n"
"| **Goal**  | `intro`    | `use`    |\n"
"| **Hypothesis** | `specialize` | `choose` |\n"
"\n"
"Now it's time for your first **Big Boss** - a problem that requires you to use almost ALL of these tactics in a single proof!\n"
"\n"
"**Lecture 1 Big Boss**\n"
"Given a function `f` and information about its behavior, prove a complex statement that involves existence, universals, algebra, and rewriting.\n"
"\n"
"This is what real mathematical proofs look like - a careful orchestration of multiple reasoning steps. You've got this! Use everything you've learned.\n"
"\n"
"**Extra Challenge**\n"
"If you want to *really* challenge yourself, play this level \"blind\". Write the assumptions and goal down on paper, close the computer, solve it by hand, keeping track *in your mind* of what happens to the game board after each command, and only once you‚Äôve worked it all out, open the computer and see if Lean accepts your solution.\n"
"\n"
"Why do you think that this would this be a good thing to do?\n"
"\n"
"In general, I hope your *goal* in taking this course is to make your \"Real Analysis Brain Muscles\" stronger. By the end, you should be *really good* at\n"
"solving Real Analysis problems on paper, where you don't have Lean showing\n"
"you the Goal State after every move.\n"
"More broadly, the purpose of learning to solve Real Analysis problems is to learn to *think*, clearly, precisely. Strengthening your ability to work with pen and paper (or just mentally) directly transfers to *any* other context where you're exploring ideas, wrestling with complicated arguments, or trying to communicate clearly to others.\n"
"\n"
"An LLM could easily work through all these Lean levels by pattern matching and logical manipulation - just as you could solve multiplication problems by plugging them into a calculator instead of memorizing your times tables. But that completely defeats the purpose of the exercise, which is to rewire your brain and build mathematical intuition. It's like deciding that you want to bench press 200 pounds, loading up the bar, and then using a forklift to lift it for you while you stand underneath - you might have moved the weight, but you haven't gotten any stronger. The real value isn't in producing correct proofs, it's in the cognitive transformation that happens when you *struggle* through the reasoning yourself, building the mental pathways that let you see mathematical structure intuitively."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Doubling a Convergent Sequence"
msgstr ""

#: Game
msgid "An Introduction to Formal Real Analysis"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "There exists a real number that makes this binomial expansion work."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "If you're struggling to prove that `2 ^ 2 = 4`, it's\n"
"a basic fact in a *ring*..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The use tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The `rewrite` tactic replaces the left-hand side of an equality with the right-hand side in the goal. The syntax is `rewrite [hypothesis_name1, hypothesis_name2, etc]`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Excellent! You've learned the `ring_nf` tactic.\n"
"\n"
"This tactic is incredibly powerful for algebraic manipulations. It automatically handles all the tedious algebra that would take many steps to do by hand.\n"
"\n"
"Your toolkit now includes:\n"
"- `apply hypothesis_name` for when a hypothesis matches your goal\n"
"- `rfl` for proving something equals itself\n"
"- `rewrite [hypothesis_name]` for rewriting using equalities\n"
"- `ring_nf` for algebraic simplifications and expansions\n"
"\n"
"As we move into real analysis proper, you'll find that `ring_nf` is invaluable for dealing with polynomial expressions, which appear everywhere in calculus!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `norm_num` tactic can normalize numerical constants and functions of them."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For a sequence `a : ‚Ñï ‚Üí ‚Ñù` and a real number `L : ‚Ñù`, we say that `SeqLim a L` holds if: for every `Œµ > 0`, there exists `N : ‚Ñï` such that for all `n ‚â• N`, we have `|a n - L| < Œµ`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The specialize tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Introduction to Lean"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Now we'll need to show that `0 < Œµ / 2`. Try: `have eps_half_pos : 0 < Œµ / 2 := by linarith [hŒµ]`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "The `choose` tactic extracts a witness from an existence statement in a hypothesis."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Apply the convergence of `a` with tolerance `Œµ / 2`. Try: `specialize h (Œµ / 2)`"
msgstr ""

#: Game
msgid "A First Course in Real Analysis"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The rw tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "If we know that $x = 5$, then we can prove that $x = 5$."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "# When things are identical to themselves\n"
"\n"
"Sometimes in mathematics, we need to prove that something equals itself. For example, we might need to prove that $x^2 + 2y = x^2 + 2y$.\n"
"\n"
"This isn't quite the same as our previous exercise. There, we had a hypothesis `h` that told us `x = 5`, and we used `apply h` to prove the goal `x = 5`.\n"
"\n"
"But now we don't have any hypothesis that says `x^2 + 2y = x^2 + 2y`. We're just being asked to prove that some expression equals itself. We can't say `apply something` because there's no `something`.\n"
"\n"
"Instead, we will use what mathematicians call the *reflexive property* of equality: everything is equal to itself. In Lean, if you get to a situation where you're trying to prove an equality, and the two things on both sides are *identical*, then the syntax is to give the command `rfl` (short for \"reflexivity\").\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "The obtain tactic"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Apply the absolute value of products: `have abs_factor : |2 * (a n - L)| = |2| * |a n - L| := by apply abs_mul`"
msgstr ""

#: Game
msgid "# Welcome to Real Analysis, The Game!\n"
"\n"
"This course is currently being developed for Rutgers University Math 311H by [Alex Kontorovich](https://math.rutgers.edu/~alexk). Please email alex.kontorovich@rutgers.edu for suggestions/corrections,\n"
"or better yet, send a PR to\n"
"https://github.com/AlexKontorovich/RealAnalysisGame.\n"
"\n"
"This course takes you through an Introduction to the Real Numbers, rigorous Œµ-Œ¥ Calculus,\n"
"and basic Point-Set Topology.\n"
"\n"
"To get started, click on\n"
"**\"Level 1: The Story of Real Analysis\"**, and good luck!"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L2Pset.L2Pset1
msgid "# Problem 1"
msgstr ""

#: Game.Levels.L2Pset.L2Pset2
msgid "For two sequences `a b : ‚Ñï ‚Üí ‚Ñù` and real numbers `L M : ‚Ñù`, with the hypotheses that `SeqLim a L` and `SeqLim b M`, the theorem `ProdLim` says that if\n"
"there is a third sequence `c : ‚Ñï ‚Üí ‚Ñù` so that for all `n`, `c n = a n * b n` (that is, `c` is the product of the sequences), then `SeqLim c (L * M)` holds."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "The `apply` tactic solves a goal when one of the hypotheses is the same as the goal. The syntax is `apply hypothesis_name`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "# Theorem Prover Software\n"
"\n"
"In this course, we will be using a \"proof assistant\" called Lean. This is software that checks that our proofs prove *exactly* what we\n"
"claim they prove. It has other really cool pedagogical features that we'll get to later.\n"
"It will take a little while to get used to the syntax, so until we're comfortable, we'll intersperse exercises teaching Lean with exercises teaching Real Analysis. Pretty soon all the exercises will just be about Real Analysis.\n"
"\n"
"\n"
"For this first exercise, we have a hypothesis that we called `h` (but we could've called it anything, like `x_eq_5`, or `Alice`) that says a real number `x` equals 5. Our goal is to prove that `x` equals 5.\n"
"This shouldn't be very hard, but if you don't know\n"
"the command, you'll be out of luck. Our goal is to\n"
"prove the same statement as one of the hypotheses.\n"
"To solve that goal, the syntax is to write `apply`, then a space, and then the name of the hypothesis which matches the goal."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
#: Game.Levels.L2Pset.L2Pset2
msgid "Problem 2"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "# Extracting information from existential quantifiers\n"
"\n"
"Now let's learn the counterpart to `use`. You know that if you have `‚àÉ` in the goal, you write `use` to provide a specific value.\n"
"\n"
"But suppose you have a *hypothesis* that says \"there exists a real number `c` such that `f (c) = 2`\". In Lean, this looks like:\n"
"`h : ‚àÉ (c : ‚Ñù), f c = 2`\n"
"\n"
"And say you want to prove that \"there exists a real number `c` such that `(f c)^2 = 4`\".\n"
"\n"
"Again, you can't just say `apply h` because these are different statements.\n"
"If you know from `h` that at least one such `c` exists, how do you *choose* one?\n"
" The name of this command is... `choose`.\n"
"\n"
"The syntax for `choose` is as follows:\n"
"\n"
"`choose c hc using h`.\n"
"\n"
"You need to give a name to both the value of `c`, and to the hypothesis with which `c` is bundled. Here we named it `hc` (a hypothesis about `c`).\n"
"\n"
"You should be able to figure out how to solve the goal from here."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
msgid "Solve the problem"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "# Problem Set 1\n"
"\n"
"Just because it's a problem set doesn't mean\n"
"you can't learn new things..."
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "# Problem 5\n"
"\n"
"You've learned about adding hypotheses with `have`, and that you can call tactics not\n"
"just to act on the Goal, but  also on hypotheses, via adding `at HypothesisName` at the end.\n"
"You also know that calling the `rewrite` tactic with a hypothesis `h : X = Y` takes the *left hand side* `X` and replaces it by `Y`. But what if you needed instead to replace `Y`'s by `X`'s? We call that \"backwards rewriting\". The syntax for that is:\n"
"\n"
"`rewrite [‚Üê h]`\n"
"\n"
"or\n"
"\n"
"`rewrite [‚Üê h] at h2`\n"
"\n"
"to do it at some other hypothesis, `h2`. You get the backwards arrow by typing \\left,\n"
"that is, the backslash, then the word `left`, and then a space.\n"
"\n"
"You may (or may not) find that useful in this problem."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For any sequence `a : ‚Ñï ‚Üí ‚Ñù` and constant `L : ‚Ñù`, and\n"
"hypothesis `h : ‚àÄ n, a n = L`, the theorem `ConstLim`\n"
"proves that `SeqLim a L`, that is, the (constant) sequence `a` converges to `L`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The binomial expansion: $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$."
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
msgid "Problem 4"
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "# Problem Set 2\n"
"\n"
"The so-called Algebraic Limit Theorem for sequences says that: if `a` and `b` are two sequences, `a b : ‚Ñï ‚Üí ‚Ñù`, and `L` and `M` are two real numbers, with `lim a = L` and `lim b = M`, then:\n"
"\n"
"- (i) for any constant `c`, `lim c * a = c * L` (you already proved this in the special case `c = 2`, and the general case is similar -- with one catch; can you tell what it is?)\n"
"- (ii) `lim (a + b) = L + M` (you already proved this as well)\n"
"- (iii) `lim (a * b) = L * M`, and\n"
"- (iv) `lim (a / b) = L / M`, as long as `M ‚â† 0`.\n"
"\n"
"Can you guess what the problem set is? :)"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "While you may see `0 < Œµ` in the goal and `Œµ > 0` in the hypothesis `hŒµ`, Lean will still know that these two things are exactly the same..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "# A First Course in Real Analysis\n"
"\n"
"You may want to pull the left-most slider all the way to the right; what follows is a discussion\n"
"between \"Socrates\" and \"Simplicio,\" which hopefully  explains what it is we're trying to do here.\n"
"\n"
"**SIMPLICIO:** What is \"Real Analysis\"?\n"
"\n"
"**SOCRATES:** Oh, it's just Calculus, but done \"right\".\n"
"\n"
"**SIMPLICIO:** Huh? Why does Calculus need a new name? What's wrong with it?\n"
"\n"
"**SOCRATES:** Well, nothing really. Quick: what's a derivative?\n"
"\n"
"**SIMPLICIO:** Easy! If I have a function $f : \\R \\to \\R$ and it's differentiable at $x$, then the\n"
"derivative is $f'(x) := \\lim_{h \\to 0}\\frac{f(x+h) - f(x)}{h}$. This represents the \"instantaneous\" slope\n"
"of the graph of the function $y=f(x)$ at the point $(x, f(x))$.\n"
"[![derivative](images/Deriv.jpg)](https://en.wikipedia.org/wiki/Derivative)\n"
"\n"
"**SOCRATES:** Very good! And tell me please, what is an integral?\n"
"\n"
"**SIMPLICIO:** That's easy, too! If you want to integrate our function $f$ along an\n"
"interval, $[a, b]$, say, you pretend that you have infinitely many, infinitely small rectangles, work out their\n"
"areas as base times height, and add them up:\n"
"$\\int_a^b f(x)dx := \\lim_{N\\to\\infty} \\sum_{j=1}^N \\frac{b-a}{N} f\\left(a + j\\frac{b-a}{N}\\right)$\n"
"[![integral](images/Integral.jpg)](https://en.wikipedia.org/wiki/Integral)\n"
"\n"
"**SOCRATES:** Great. And what are the two Fundamental Theorems of Calculus?\n"
"\n"
"**SIMPLICIO:** These too are easy! The first one says that if you make a new function by integrating $f$\n"
"up to a variable amount, $x$, that is, let\n"
" $F(x) := \\int_a^x f(t)dt$, then the derivative of the new function is just $F'(x) = f(x)$.\n"
"\n"
"**SOCRATES:** And the second?\n"
"\n"
"**SIMPLICIO:**\n"
"The second one says that, conversely, if $F$ is an antiderivative of $f$, that is, $F'(x)=f(x)$, then\n"
"it's easy to work out the area under the curve, because\n"
" $\\int_a^b f(x)dx = F(b) - F(a)$.\n"
"So differentiation and integration are inverse operations!\n"
"\n"
"**SOCRATES:** Perfect. Now, here's the problem. You used words like \"limit\", \"infinitely many\", \"infinitely small\", and so on. What do they *actually* mean?\n"
"\n"
"**SIMPLICIO:** Oh, you know, it's when something  happens \"eventually\". You just have to get used to\n"
"the feel of it.\n"
"\n"
"**SOCRATES:** Hmm yes, I see. I agree that that's an OK way to think of it, for a while at least, and one that suited Newton (who\n"
"was quite uncomfortable with such words), and Leibniz (who was more care-free here), the two 17th century inventors of\n"
"calculus (if you don't count people like the ancient Greeks Eudoxus and Archimedes, or the 14th century Indian Madhava... but this isn't a history lesson). Leibniz taught the Bernoulli\n"
"brothers (the world's \"first AP Calc students\"!), who taught, among others, the Marquis de l'Hopital, and the great Leonhard Euler (the first \"Calc native\"), who taught the rest of us. All was going quite well... and then came the 19th Century.\n"
"[![NewtonLeibnizEudoxusArchimedesMadhavaBernoulliEuler](images/People.jpg)](https://en.wikipedia.org/wiki/History_of_calculus)\n"
"\n"
"**SIMPLICIO:** Huh? What happened in the 19th Century?\n"
"\n"
"**SOCRATES:** Well you see, a guy named Augustin-Louis Cauchy came along (roughly in the 1810s), and started making a fuss that we weren't really doing things perfectly \"rigorously\".\n"
"He set out to reprove the theorems of calculus using precise definitions rather than hand-waving.\n"
"He was making great progress, including proving statements like: the limit of continuous functions is continuous.\n"
"[![Cauchy](images/Cauchy.jpg)](https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy)\n"
"\n"
"**SIMPLICIO:** Sure, that sounds perfectly reasonable. A limit is a continuous process, so you do that to\n"
"continuous functions, and of course in the end you should get something continuous, too.  No?\n"
"\n"
"\n"
"**SOCRATES:** Well, the problem is that around the same time, a guy named Joseph Fourier was going around claiming\n"
" that he could add up a bunch of sines and cosines, and get basically any function he wants, including, say, the discontinuous sawtooth!\n"
"\n"
"**SIMPLICIO:** What?!\n"
"\n"
"**SOCRATES:** Look for yourself: Here's a graph of $\\sum_{n=1}^{100}\\frac1n \\sin(nx)$. As you take 100\n"
"out to infinity, Fourier claims that this will get\n"
"closer and closer to a sawtooth function!\n"
"[![Fourier](images/Fourier.jpg)](https://en.wikipedia.org/wiki/Joseph_Fourier)\n"
"\n"
"**SIMPLICIO:** Whoa. Wait, I can think of an even easier example: just look at the simplest family of\n"
"polynomials, $f_n(x) = x^n$, on the unit interval $[0,1]$. When you take high powers of any point\n"
"strictly less than $1$, that goes to $0$ in the limit, but powers of $1$ itself always stay at $1$.\n"
"So the limiting function is discontinuous, too! What the heck is going on here?\n"
"![Power Functions](images/Powers.png)\n"
"\n"
"\n"
"**SOCRATES:** Very good, Simplicio! Exactly right, between Fourier and Cauchy, they \"broke math\".\n"
" You break it, you buy it!\n"
"\n"
"**SIMPLICIO:** Ok, so what's the right answer, how *do* you do calculus rigorously?\n"
"\n"
"**SOCRATES:** Not so fast! Things got even worse, and by the mid-19th century, people realized that\n"
"we don't even know what the real numbers *are*!\n"
"\n"
"**SIMPLICIO:** What? What do you mean, what are they? Here they are right here: There's zero, and one, and $-2$, and $\\frac35$, and\n"
"$\\sqrt 2$, and $e$ and $\\pi$. What's the problem?\n"
"[![RealNumbers](images/RealLine.png)](https://en.wikipedia.org/wiki/Real_number)\n"
"\n"
"**SOCRATES:** Well, do you remember that you need something called the Intermediate Value Theorem\n"
"in calculus?\n"
"\n"
"**SIMPLICIO:** Sure, if you have a continuous function, and it goes from being negative to being positive,\n"
"then it has to cross zero at some point in between.\n"
"\n"
"**SOCRATES:** Very good. Tell me about the function $f : x \\mapsto x^2 - 2$. (We say: \"$f$ maps\n"
"$x$ to $x^2-2$\". Note that we write $f : \\R \\to \\R$ to mean that $f$ takes real numbers to real numbers, but\n"
"replace $\\to$ with $\\mapsto$ (see the tail on the second arrow?) when we want to say what happens to a particular input $x$ under the action of\n"
"$f$. Let me remind you that $x$ here is a dummy variable, so it's the same function if we'd said $f : u \\mapsto u ^ 2 - 2$.) In particular, what happens to $f$ on the rational numbers?\n"
"\n"
"**SIMPLICIO:** Ok, well if $x$ is a rational number, then so is $x^2$, and hence so is $x^2-2$.\n"
"So actually, we could say that $f : \\mathbb Q \\to \\mathbb Q$, that is, $f$ maps rational numbers to rational numbers.\n"
"Over the reals, the graph of $y=f(x)$ is a simple parabola.\n"
"But you'd asked me about the Intermediate Value Theorem. Hmm. When $x=0$, I know that $f(x)$ will\n"
"be $f(0)=0^2-2=-2$ which is negative. And when $x=2$, $f(2)=2^2-2=2$ which is positive.\n"
"\n"
"**SOCRATES:** Go on...\n"
"\n"
"**SIMPLICIO:** So there's a root of $f$ somewhere between $0$ and $2$. But the place where $f$ crosses the $x$-axis is at $x=\\sqrt2\\approx 1.41\\dots$.\n"
"\n"
"**SOCRATES:** And what did the Pythagoreans know about this number?\n"
"\n"
"**SIMPLICIO:** Supposedly one of them, Hippasus, figured out that $\\sqrt2$ is irrational, which ruined\n"
"their entire theory of geometry and form (they originally believed that *all* numbers were rational); legend has it\n"
"that Hippasus was drowned at sea for his herecy.\n"
"\n"
"**SOCRATES:** So...\n"
"\n"
"**SIMPLICIO:** So wait, if we just restrict to rational inputs, then this parabola is negative, and then\n"
"it's positive, and it *never* crosses zero?! But there's tons of rational numbers almost everywhere you look. So what makes the real numbers different from the\n"
"rational numbers, so that the Intermediate Value Theorem actually holds?\n"
"\n"
"**SOCRATES:** Ah! Now, my friend, we are ready to begin."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "# Universal statements\n"
"\n"
"In mathematics, we often need to prove statements that are true \"for all\" values of some variable. For example, we might want to prove: \"for all $\\varepsilon > 0$, we have $(\\varepsilon + 1)^2 = (\\varepsilon + 1)^2$.\"\n"
"(Of course the condition that `Œµ` be positive is mathematically superfluous, and is only here for pedagogical purposes.)\n"
"\n"
"If you're thinking that `rfl` will do the trick, that's a good idea, but it won't work, because the goal isn't (yet) an equality. So we need to do something else first.\n"
"\n"
"In Lean, as in mathematics, \"for all\" is written using `‚àÄ`; this is called the *universal quantifier*, and is gotten by typing \\forall, that is, backslash, then `forall`, then a space. In Lean, this goal looks like so:\n"
"\n"
"`‚àÄ Œµ > 0, (Œµ + 1)^2 = (Œµ + 1)^2`.\n"
"\n"
"(Note that to write an epsilon in Lean, you just type \\\\e, that is, backslash, then `e`, then space.)\n"
"\n"
"To prove a \"for all\" statement, you need to show that it's true for an arbitrary element. In English, you would say: give me an arbitrary `Œµ`, and give me the fact that it's positive (we can give that fact a name, like `hŒµ`, since it's a hypothesis about `Œµ`, or perhaps an even more descriptive name like `Œµ_pos`, since the hypothesis is the positivity of `Œµ`). Note that `Œµ` here is a dummy variable, and we could choose to name it something else on the fly. In English, we might say: give me some `Œµ`, but I want to call it `Alice`; then give me the fact that `Alice` is positive, and my goal will be to prove that `(Alice + 1)^2 = (Alice + 1)^2`. If we were more polite, we might replace \"give me\" above with \"introduce\", like:\n"
"introduce an `Œµ`, and introduce the fact, call it `hŒµ`, that `Œµ` is positive.\n"
"\n"
"In Lean, the syntax for this is the command `intro`, followed by whatever name you want to give a dummy variable or a hypothesis.\n"
"\n"
"So: when you see a goal that starts with `‚àÄ`, you can write `intro` to \"introduce\" the variable. For example:\n"
"- `intro Œµ` introduces the variable Œµ. But look at the goal state now! It changes to: `Œµ > 0 ‚Üí (Œµ + 1)^2 = (Œµ + 1)^2`. So we're not done introducing things.\n"
"- Then `intro hŒµ` introduces the hypothesis that `Œµ > 0` (and again, you can call the hypothesis whatever you want; try `intro Œµ_pos` instead).\n"
"\n"
"After using `intro` twice, the goal will become one that you\n"
"should know how to solve.\n"
"\n"
"If you want to be really slick, you can combine the two `intro` commands into\n"
"one: `intro Œµ hŒµ`. But don't feel obliged."
msgstr ""

#: Game
msgid "*An Introduction to Formal Real Analysis - Interactive Edition*\n"
"\n"
"## About this Course\n"
"\n"
"This course follows the historical crises that forced mathematicians to rebuild\n"
"mathematics from the ground up in the 19th century. You'll learn why concepts\n"
"like Œµ-Œ¥ definitions became necessary and how to use them to do advanced calculus.\n"
"\n"
"## Credits\n"
"\n"
"* **Course Design:** By Alex Kontorovich alex.kontorovich@rutgers.edu\n"
"* **Interactive Implementation:** Lean 4 Game Engine\n"
"* **Mathematical Content:** Following Rudin, Stein-Shakarchi, etc."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
msgid "Done."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The Convergence of a Sequence"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "# The Mathematical Revolution of 1666\n"
"\n"
"**SIMPLICIO:** I heard that Newton had a really cool way of calculating œÄ. Can you tell me about it?\n"
"\n"
"**SOCRATES:** Certainly. It begins around 1665-1666, when Newton was turning 23 years old. Anything significant about that year?\n"
"\n"
"**SIMPLICIO:** Isn't that Newton's  \"annus mirabilis\",  year of miracles? If I recall correctly, he was forced to leave Cambridge due to an outbreak of  the Great Plague, and made his most groundbreaking discoveries (calculus, optics, gravitation, etc) while quarantining in isolation at his family home in Woolsthorpe.\n"
"\n"
"**SOCRATES:** Exactly right. And one of the first things he discovered in that year was a  new version of\n"
"the Binomial Theorem. Tell me, please,  what can one say about\n"
"$(1 + x) ^ n$?\n"
"\n"
"**SIMPLICIO:** Sure thing, if you multiply $(1+x)^n$ all out, you get\n"
"$ \\binom{n}{0} + \\binom{n}{1}x + \\binom{n}{2}x^2 + \\cdots + \\binom{n}{n}x^n$. Here $\\binom{n}{k}$ is the \"binomial coefficient\", the number of ways of choosing $k$ things from a bag of $n$ things. Explicitly, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. These are just the numbers in Pascal‚Äôs Triangle, and you can easily read off the $n$-th row.\n"
"[![Pascal's Triangle](images/Yanghui_triangle.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"\n"
"**SOCRATES:** Excellent! And do you know sigma notation?\n"
"\n"
"**SIMPLICIO:** I think so. I could‚Äôve written  that same thing as $\\sum_{k=0}^{n} \\binom{n}{k} x^k$. In general, if you have some function $f: \\mathbb{N} \\to \\mathbb{R}$, and you want express $f(a)+f(a+1)+‚Ä¶+f(b)$, that is, the sum of $f(k)$ as $k$ ranges from some integer $a$ up to some other integer $b$, you can write it as $\\sum_{k=a}^{b} f(k)$.\n"
"\n"
"**SOCRATES:** Very good.  So we have $(1+x)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^k$. Now, would you allow me to write this as a sum going all the way out to infinity?\n"
"$(1+x)^n = \\sum_{k=0}^{\\infty} \\binom{n}{k} x^k$\n"
"\n"
"**SIMPLICIO:** Hmm. Ok, I think I see what you‚Äôre getting at: Pascal‚Äôs Triangle has implied zeros everywhere outside, so $\\binom{n}{k}$ is just zero once $k>n$. So you‚Äôve written it as an infinite sum, even though it secretly terminates after finitely many terms. But what purpose does extending it serve?\n"
"\n"
"**SOCRATES:** Well, let me ask you this: can you think of any way of making sense of this formula when $n=-1$?\n"
"\n"
"**SIMPLICIO:** Huh? You can‚Äôt use binomial coefficients. How do you choose 3 things from -1 things, that makes no sense!\n"
"\n"
"**SOCRATES:** Ok, sure, but so many great discoveries in mathematics occur when you realize a way to **break the rules**, and follow some pattern **past** its intended... limit (no pun intended‚Ä¶). Put yourself in Newton‚Äôs shoes, if you can; what might a genius like him come up with?\n"
"\n"
"**SIMPLICIO:** Well, we do have this other formula for binomial coefficients, not in terms of combinatorics, but just as factorials, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. That still doesn‚Äôt help because what the heck is $(-1)!$ supposed to be?! Oh, but wait! We can also write this as:\n"
"\n"
" $\\binom{n}{k} = \\frac{n(n-1)(n-2)\\cdots(n-k+1)}{k!}$\n"
"\n"
"And in this way, we ‚Äúbypass‚Äù the issue of dealing with $(-1)!$, and just go straight to ‚Äúnormal‚Äù numbers.\n"
"\n"
"**SOCRATES:** Can you please write this using product notation?\n"
"\n"
"**SIMPLICIO:** Sure, it's just like summation notation but with a $\\Pi$:\n"
"\n"
" $\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=1}^{k}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Whoops, are you sure about those bounds in the product?\n"
"\n"
"**SIMPLICIO:** Argh! It's so easy to make a silly mistake.\n"
"After writing down the formula, I should have\n"
"checked that I got the right start and end values;\n"
"the counter $\\ell$ should go from $0$ to $k-1$, not from $1$ to $k$.  Is this better?\n"
"\n"
"$\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Perfect. Go on.\n"
"\n"
"**SIMPLICIO:** Ok, so if we agree to follow this pattern, then we get:\n"
"\n"
"- $\\binom{-1}{0} = 1$, which makes sense because any row of Pascal's triangle starts with at $1=\\binom{c}{0}$; then\n"
"\n"
"- $\\binom{-1}{1} = (-1)/1! = -1$, which also makes sense because the next term in the \"$c$th row\" of Pascal's triangle is always\n"
"$\\binom{c}{1} = c$; then we get:\n"
"\n"
"- $\\binom{-1}{2} = (-1)(-2)/2! = +1$,\n"
"\n"
"- $\\binom{-1}{3} = (-1)(-2)(-3)/3!=-1$.\n"
"\n"
"Ok so I see the pattern:\n"
"it just alternates between $+1$ and $-1$, so the series goes:\n"
"\n"
" $(1+x)^{-1} = 1 - x + x^2 - x^3+x^4-x^5+\\cdots$.\n"
"\n"
"**SOCRATES:** Very good! But does this formula make any actual\n"
"*sense*? How might you test it?\n"
"\n"
"**SIMPLICIO:** Ok, if that series is supposed to \"represent\"\n"
"$1/(1+x)$, then if I multiply the whole thing by\n"
"$(1+x)$, I should just get $1$. Let's try it:\n"
"\n"
"$(1+x)(1 - x + x^2 - x^3+x^4-x^5+\\cdots) = ?$\n"
"\n"
"I'll first multiply everything by $1$, then by $x$, and add them all up.\n"
"\n"
"$(1 - x + x^2 - x^3+x^4-x^5+\\cdots) + (x - x^2 + x^3- x^4+x^5\\cdots)$\n"
"\n"
"Ok, so if I rearrange terms, then everything cancels out, and only the leading $1$ remains. Great!\n"
"\n"
"**SOCRATES:** Interesting. And are you \"allowed\" to rearrange terms like that?\n"
"\n"
"**SIMPLICIO:** Well.... why not?\n"
"\n"
"**SOCRATES:** Ok, nevermind that for now,\n"
"you seem to be satisfied that it makes sense to say\n"
"that the series\n"
"$1 - x + x^2 - x^3+x^4-x^5+\\cdots$ \"converges\" (again, whatever that means) to $(1+x)^{-1}$.\n"
"\n"
"**SIMPLICIO:** Come to think of it, I knew this already;\n"
"it's just the geometric series! I know that\n"
"\n"
"$1+\\lambda + \\lambda^2+\\lambda^3+\\cdots$\n"
"\n"
"adds up to $1/(1-\\lambda)$, and the series we have just replaces $\\lambda$ with $-x$.\n"
"\n"
"**SOCRATES:** Yes, very good.\n"
"And where might this \"belong\" in Pascal‚Äôs triangle?\n"
"\n"
"**SIMPLICIO:**\n"
"Holy cow! Did we just discover an extension of the triangle, going ‚Äúup‚Äù?!\n"
"[![Pascal's Triangle, Extended](images/PascalM1.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:**\n"
"Indeed, and we can in fact continue this pattern for $n=-2,\n"
"-3, -4,$ and so on. I'll let you work it out yourself, but we actually\n"
"get a *whole other* Pascal's triangle (with some negative signs) *above* the standard one!\n"
"[![Pascal's Triangle, Extended](images/PascalMn.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"See how it still follows the usual rule, that the two numbers above and to the left or right add to the value just below them?\n"
"\n"
"But let's try something even more exotic. Can you make\n"
"the Binomial Theorem work when $n=1/2$?\n"
"\n"
"\n"
"**SIMPLICIO:** Whoa, $n = 1/2$? That's... really pushing it! But let me try using the same formula. So $\\binom{1/2}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(1/2-\\ell)$. Let me work out the first few terms:\n"
"\n"
"- $\\binom{1/2}{0} = 1$ (as always)\n"
"\n"
"- $\\binom{1/2}{1} = (1/2)/1! = 1/2$ (again, matches the pattern we already knew)\n"
"\n"
"- $\\binom{1/2}{2} = (1/2)(-1/2)/2! = -1/8$\n"
"\n"
"- $\\binom{1/2}{3} = (1/2)(-1/2)(-3/2)/3! = 1/16$\n"
"\n"
"- $\\binom{1/2}{4} = \\frac{(1/2)(-1/2)(-3/2)(-5/2)}{4!} =  -\\frac{5}{128}$\n"
"\n"
"So $(1+x)^{1/2} = 1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots$\n"
"\n"
"But wait -- this is supposed to be $\\sqrt{1+x}$?!\n"
"\n"
"**SOCRATES:** Again, go into Newton's thinking: how might he go about justifying whether this formula makes any sense?\n"
"\n"
"**SIMPLICIO:** Oh, ok, I think I see! If we square the formula and multiply everything out, I guess we're supposed to get $1+x$ -- that would justify calling the series $\\sqrt{1+x}$.\n"
"\n"
"**SOCRATES:** Go for it!\n"
"\n"
"**SIMPLICIO:** Ok, so I want\n"
"\n"
"$\\left(1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots\\right)^2$\n"
"\n"
"That means squaring every term, and also adding twice every product of distinct pairs of terms.\n"
"\n"
"**SOCRATES:** Right. Can you think of a good way of keeping track of everything?\n"
"\n"
"**SIMPLICIO:** Oh, I know! Let's group things by the power of $x$ involved. The first one is easy: $x^0=1$, which you only get from squaring the first term. So that coefficient is $1$.\n"
"\n"
"For the coefficient of $x^1$, I can't square anything involving $x$'s, so I\n"
"can only multiply the $x$ term by the constant term, and of course double it.\n"
"That's just $2 \\times 1 \\times \\frac{1}{2}x = x$. So the coefficient of $x$ is $1$.\n"
"\n"
"For $x^2$, I get two contributions  from constant times quadratic: $2 \\times 1 \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{4}x^2$ and also from the square of the linear term: $\\left(\\frac{1}{2}x\\right)^2 = \\frac{1}{4}x^2$. So the total coefficient is $-\\frac{1}{4} + \\frac{1}{4} = 0$.\n"
"\n"
"Let's try a few more. To get $x^3$, I need:\n"
"- $2 \\times 1 \\times \\frac{1}{16}x^3 = \\frac{1}{8}x^3$ (constant times the $x^3$ term)\n"
"- $2 \\times \\frac{1}{2}x \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{8}x^3$ (the $x$ term times the $x^2$ term)\n"
"\n"
"So the total coefficient of $x^3$ is $\\frac{1}{8} - \\frac{1}{8} = 0$.\n"
"\n"
"This is amazing! It really seems like all the higher-order terms are canceling out perfectly. I bet that will keep happening, and we'll just get the square to come out to exactly $1+x$; the formula really works!\n"
"\n"
"So wait, now we get a whole other row in Pascal's triangle, *between* rows $0$ and $1$?!\n"
"\n"
"[![Pascal's Triangle](images/PascalM12.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:** Beautiful, isn't it!\n"
"\n"
"**SIMPLICIO:** Wait, this is all much simpler than I'm making it. Isn't this just the same thing as the Taylor expansion about $x=0$ of the function $f(x)=\\sqrt{1+x}$?\n"
"I already know how to do this from Calculus.\n"
"\n"
"**SOCRATES:** Yes, very good; but Brook Taylor (of Taylor series) did not prove his general theorem until 1715, a few decades after\n"
"Newton's computation of $\\pi$.\n"
"\n"
"Now, suppose you wanted to compute something like $\\sqrt 3$ -- can you think of a way of doing it using this formula?\n"
"\n"
"**SIMPLICIO:** Hmm the function is $\\sqrt {1+x}$, so I guess I want to set $x=2$. Then I get:\n"
"\n"
"$\\sqrt {1+2} = 1 + \\frac{1}{2}(2) - \\frac{1}{8}(2)^2 + \\frac{1}{16}(2)^3 -\n"
"\\frac{5}{128}(2)^4 + \\cdots$\n"
"\n"
"Adding up these five terms comes out to $11/8 = 1.375$, not so close to $\\sqrt3\\approx1.73$. And the individual terms\n"
"are not so small, for instance, the last one, $\\frac{5}{128}(2)^4 = 5/8 = 0.625$.\n"
"\n"
"**SOCRATES:** Well, sure, if you set $x$ to be large, like $x > 1$, then the powers of $x$ are also larger and larger (and exponentially so!)... Can you think of something else you could do?\n"
"\n"
"**SIMPLICIO:**\n"
"Ah, I think I see! I know that\n"
"$3$ is near $4$, which is a perfect square. So what if we write\n"
"\n"
"$\\sqrt 3 = \\sqrt{4-1} = \\sqrt{4(1-\\frac14)}=2\\sqrt{1-\\frac14}$\n"
"\n"
"So now if I apply our formula with $x=-1/4$ (which is less than one!), I guess I'll get:\n"
"\n"
"$\\sqrt3 \\approx 2\\left(\n"
"1 + \\frac{1}{2}(-1/4) - \\frac{1}{8}(-1/4)^2 + \\frac{1}{16}(-1/4)^3 -\n"
"\\frac{5}{128}(-1/4)^4+\\cdots\n"
"\\right)$\n"
"\n"
"Taking just these five terms, the fraction on the right comes out to $28379/16384\\approx 1.73212$, which is impressively close to $\\sqrt3\\approx1.7320508$.\n"
"We got 3 decimal places of accuracy, nice!\n"
"\n"
"**SOCRATES:** Great! Now you see the power of Newton's Binomial Theorem. Ok, so then let's return all the way back to your original question, about Newton's estimate for $\\pi$.\n"
"\n"
"**SIMPLICIO:** Hmmm, $\\pi$ is the ratio of circumference to diameter in a circle. So where am I supposed to find a length.\n"
"\n"
"**SOCRATES:** Ah, but what did we learn from Archimedes?\n"
"\n"
"**SIMPLICIO:** Oh, that $\\pi$ is also an *area*, not just a length. It's the area of a unit circle $\\pi r^2$ where $r=1$.\n"
"\n"
"**SOCRATES:** Beautiful. And could you find a circle's area lurking somewhere?\n"
"\n"
"**SIMPLICIO:**  I think I see it! Thanks to Descartes, and \"Cartesian\" coordinates, we can express the  circle as the graph of $x^2+y^2=1$, or to make it a function, $y=\\sqrt{1-x^2}$. So we just have to replace $x$ in our series with $-x^2$.\n"
"\n"
"$\n"
"\\sqrt{1-x^2}\n"
"= 1 + \\frac{1}{2}(-x^2) - \\frac{1}{8}(-x^2)^2 + \\frac{1}{16}(-x^2)^3 - \\frac{5}{128}(-x^2)^4+\\cdots\n"
"$\n"
"\n"
"$\n"
"= 1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\n"
"$\n"
"\n"
"And the area under the curve $y=\\sqrt{1-x^2}$ from $x=0$ to $x=1$ is\n"
"a quarter circle.\n"
"[![Quarter Circle](images/PiOver4.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"\n"
"**SOCRATES:** Luckily, Newton had just invented calculus! So how else\n"
"could he compute the area under this curve?\n"
"\n"
"**SIMPLICIO:** With an integral! So:\n"
"\n"
"$\\frac{\\pi}4 = \\int_0^1 \\sqrt{1-x^2} \\, dx =\n"
"\\int_0^1 \\left(1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\\right) dx$\n"
"\n"
"I'll just integrate term by term,...\n"
"\n"
"**SOCRATES:** Whoa, hang on! Why are you allowed... You know what, nevermind, sorry.\n"
"Just go ahead.\n"
"\n"
"**SIMPLICIO:** Ok, weirdo. Anyway. So integrating term by term, I get:\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"$= 1 - \\frac{1}{6} - \\frac{1}{40} - \\frac{1}{112} - \\frac{5}{1152} - \\cdots $\n"
"\n"
"Wow! So Newton got an infinite series for $\\pi$!\n"
"If I evaluate just these five terms, and cross multiply by the factor of $4$, I get the fraction\n"
"$32057/10080\\approx 3.180$, not bad!\n"
"\n"
"**SOCRATES:** Not bad indeed. You know, Simplicio, many math papers have roughly zero new ideas; they're just\n"
"doing something nobody bothered to do before in a slightly\n"
"newer context. A really good math paper can have one or two genuinely new ideas. Newton is already on new idea number five, and he's still not done!\n"
"\n"
"**SIMPLICIO:** Ok, so what's new idea number six?\n"
"\n"
"**SOCRATES:** Well, remember how you integrated all the way up to $x=1$? In your series,\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"you have all these high powers of $x$ but they're being \"wasted\" because you're setting $x$ to $1$. What if instead  you only integrated up to, say, $x=1/2$?\n"
"\n"
"**SIMPLICIO:** Ooh, cool! Then the series will converge much more rapidly. But wait, that changes the geometry. Instead of a quarter-circle, we now have... a 30 degree sector, which has area $\\pi/12$, plus a 30-60-90 triangle -- ah that must be why you suggested $x=1/2$ -- with area $\\frac12\\times\\frac12\\times\\frac{\\sqrt3}2$.\n"
"\n"
"[![Integrating to x=1/2](images/PiOver12.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"Good thing we already know how to quickly estimate $\\sqrt3$ to high accuracy! (Ah, that's the trade-off: we could set $x$ even smaller, for faster convergence, but then we'll need to deal with ever more complicated geometric evaluations; so $x=1/2$ is a \"sweet spot\".) So now:\n"
"\n"
" $ \\frac{\\pi}{12} +  \\frac{\\sqrt3}8 =\n"
"\\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^{1/2}$\n"
"\n"
"$ = \\frac12 - \\frac{1}{6}\\left(\\frac12\\right)^3 - \\frac{1}{40}\\left(\\frac12\\right)^5 - \\frac{1}{112}\\left(\\frac12\\right)^7 - \\frac{5}{1152}\\left(\\frac12\\right)^9 - \\cdots.$\n"
"\n"
"Again evaluating just these five terms already gives the fraction $9874097/20643840$.\n"
"And now isolating $\\pi$ gives the estimate\n"
"\n"
"$\\pi \\approx 12\\times\\left(9874097/20643840 -  \\frac{\\sqrt3}8\\right) \\approx 3.14161,$\n"
"\n"
"which is off by two parts in $100,000$ from the true estimate $\\pi \\approx 3.14159$. All that with just five terms, amazing!\n"
"\n"
"\n"
"**SOCRATES:** Yes, Newton was very impressive indeed.\n"
"Here's a nice YouTube video by Veritasium that discusses this whole saga (right-click to get it to pop up in a new tab):\n"
"[![Veritasium Video](https://img.youtube.com/vi/gMlf1ELvRzc/maxresdefault.jpg)](https://youtu.be/gMlf1ELvRzc)\n"
"\n"
" In fact, a series for $\\pi$ similar to this one was discovered two centuries earlier, by the Indian mathematician Madhava of Sangamagrama.\n"
" And it would take two more centuries until mathematicians figured out how to rigorously justify Newton's work. To do so, they had to figure out:\n"
"\n"
"- What it meant for a sequence of real numbers $a_0, a_1, a_2,\\dots$ to converge?\n"
"- What it meant for a series (that is, sequence of partial sums) $a_0 + a_1 + a_2 +\\cdots$ to converge, and could we sum these numbers in any order we like,\n"
"- What it meant for a series involving a variable, like a power series $a_0 + a_1  x + a_2  x^2+\\cdots$ to converge, and if so, what kind of function it converged to,\n"
"- When can we interchange limits with integrals, like integrating term by term, $\\int(a_0 + a_1  x + a_2  x^2+)dx\\cdots \\overset{?}=\\int \\, a_0\\, dx+\\int \\, a_1  x\\, dx+\\int\\, a_2  x^2\\, dx+\\cdots$,\n"
"\n"
"Etc, etc. We have a lot of work to do!\n"
"\n"
"**SIMPLICIO:** Ok, ok; you've convinced me! On with some actual Real Analysis please."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Write `apply h` since the hypothesis `h` is  what we want to prove."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "# Algebraic manipulations\n"
"\n"
"Now let's learn about algebraic simplification. Suppose you need to prove that $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$.\n"
"\n"
"This is true by the basic laws of algebra - expanding the left side using the distributive law, commutativity, associativity, etc. But doing this by hand would be extremely tedious.\n"
"\n"
"Fortunately, Lean has a powerful tactic called `ring_nf` (\"ring normal form\") that can automatically perform algebraic manipulations like:\n"
"- Expanding products\n"
"- Collecting like terms\n"
"- Rearranging using commutativity and associativity\n"
"- Applying the distributive law\n"
"\n"
"When you have an algebraic identity involving addition, subtraction, and multiplication, `ring_nf` can often prove it automatically.\n"
"\n"
"Try it out on this classic binomial expansion!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "This is where you might find it useful to call `norm_num` and normalize `|0|` to `0`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_obtain
msgid "Excellent! You've learned the `choose` tactic for working with existence in hypotheses.\n"
"\n"
"Notice the complete pattern:\n"
"1. `choose c hc using h` unpacked the hypothesis into a specific value `c` and proof `hc : f c = 2`\n"
"2. `use c` provided this same value as our witness for the goal\n"
"3. `rewrite [hc]` rewrote `f c` as `2` in the goal, changing it to `2^2 = 4`\n"
"4. `ring_nf` verified that `2 ^ 2 = 4`\n"
"\n"
"The symmetry is beautiful:\n"
"- `use` when you have `‚àÉ` in the goal (\"here's my specific example\")\n"
"- `choose` when you have `‚àÉ` in a hypothesis (\"let me unpack this existence claim\")\n"
"\n"
"This completes your basic logical toolkit! In real analysis, you'll use `obtain` constantly when working with:\n"
"- Limit definitions (\"given Œµ > 0, there exists Œ¥ > 0...\")\n"
"- Intermediate Value Theorem (\"there exists c such that f(c) = 0\")\n"
"- Existence theorems throughout analysis\n"
"\n"
"You're now ready to tackle real mathematical proofs!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "If a function of `x` always equals `x¬≤`, then it equals `t¬≤` when evaluated at `t`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "For all positive real numbers, this algebraic identity holds."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Every mathematical expression equals itself."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L2Pset.L2Pset1
msgid "Problem 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Write `use 42`, but with `42` replaced by the correct answer. Then how should you finish?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Type `rewrite [Bob]` to replace `x` with `2` in the goal. Then what?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The `ring_nf` tactic puts both sides of an equation into a standard algebraic form and checks if they're equal."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Use `intro Œµ` to introduce the variable, then `intro hŒµ` to introduce the hypothesis `Œµ > 0`. Then how do you solve the goal?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "Lecture 1: The Story of Real Analysis"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L03_SumOfSeqs
msgid "Big Boss: The Sum of Convergent Sequences"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "# Rewriting with equalities\n"
"\n"
"Now let's learn about rewriting. Suppose you have a hypothesis called `Bob : x = 2`, and your goal is to prove that `x + y = 2 + y`.\n"
"\n"
"Can you use `rfl`? No, because the two sides of the goal (`x + y` and `2 + y`) are not *identically* the same.\n"
"\n"
"Can you use `apply Bob`? No, because `Bob` says `x = 2`, which is not what the goal is asking for.\n"
"\n"
"But you can use the hypothesis `Bob` to *rewrite* the goal. Since `Bob` tells us that `x = 2`, we can replace `x` with `2` in our goal.\n"
"\n"
"In Lean, if you have a hypothesis which is an equality, and you want to replace the *left hand side* of that equality with the *right hand side* in your goal, you use the `rewrite` tactic. The syntax is:\n"
"\n"
"`rewrite [hypothesis_name]`\n"
"\n"
"Unfortunately, those square brackets are part of the Lean syntax, and there's nothing you or I can do about them right now. Just remember: `rewrite [Bob]` means \"use the equality in `Bob` to rewrite the goal.\"\n"
"\n"
"After you rewrite, you're not done. But you should know how to finish from there.\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Great! You've learned the `rewrite` tactic.\n"
"\n"
"Notice what happened: after you typed `rewrite [Bob]`, the goal changed from `x + y = 2 + y` to `2 + y = 2 + y`. Then you needed to type `rfl` to finish the proof, since both sides were now identical.\n"
"\n"
"So far you've learned:\n"
"- `apply hypothesis_name` when a hypothesis matches your goal\n"
"- `rfl` when you need to prove something equals itself\n"
"- `rewrite [hypothesis_name]` when you want to use an equality to rewrite your goal\n"
"\n"
"The `rewrite` tactic is incredibly powerful and you'll use it constantly in real analysis!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# üéâ Excellent Work! üéâ\n"
"\n"
"You've just completed your first rigorous limit proof! Let's reflect on what you accomplished and the key insights from this foundational example.\n"
"\n"
"**What you just proved:**\n"
"You showed that if a sequence always outputs the same value `L`, then it converges to `L`. The Machinist's response to any tolerance demand `Œµ > 0` is beautifully simple: 'I can meet that specification immediately with any production run length `N`, because I'm already producing exactly what you want!'\n"
"\n"
"**Key Insights from this proof:**\n"
"\n"
"1. **The `change` tactic**: You learned how to unfold a definition to see what you're really trying to prove. `SeqLim a L` became the concrete epsilon-N condition.\n"
"\n"
"2. **The logical structure**: The proof followed the natural flow of the definition:\n"
"   - `intro Œµ hŒµ` handled 'for every Œµ > 0'\n"
"   - `use 1` provided the witness `N` (any number works!)\n"
"   - `intro n hn` handled '‚àÄ n ‚â• N'\n"
"   - Then algebraic manipulation showed that `|a n - L| = |L - L| = |0|`\n"
"   - Then numerical normalization gave that `|0| = 0`, and `hŒµ` finally proved that `|a n - L| < Œµ`.\n"
"\n"
"**The Beautiful Simplicity:**\n"
"This is the Machinist's dream scenario‚Äîno matter how demanding the engineer's tolerance requirements, the constant factory can satisfy them instantly. There's no trade-off between precision and effort because the output is already perfect!\n"
"\n"
"You're building the foundation for all of calculus. Every limit, derivative, and integral ultimately rests on arguments like this one.\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Let's step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If a sequence has the same value for every term, then it converges to that constant value.\n"
"\n"
"**Proof:** Suppose we have a sequence $a(n)$ where $a(n) = L$ for all $n$, and we want to show that this sequence converges to $L$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|a(n) - L| < \\varepsilon$.\n"
"\n"
"This is almost trivially simple: since $a(n) = L$ for every $n$, we have:\n"
"$$|a(n) - L| = |L - L| = |0| = 0$$\n"
"\n"
"Since $0 < \\varepsilon$ for any positive $\\varepsilon$, we can choose any $N$ we want (we chose $N = 1$ in the proof, but $N = 0$ or $N = 1000$ would work equally well).\n"
"\n"
"Therefore, for any $n \\geq N$, we have $|a(n) - L| = 0 < \\varepsilon$, which proves convergence.\n"
"**QED**"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The ring_nf tactic"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
msgid "Given that `f (u) = 2 * u + 1` for all `u`, prove that there exists some `a` such that `f (3) = a`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "# Proving existence\n"
"\n"
"Sometimes in mathematics, you need to prove that something exists. For example, suppose I wanted to ask you what the binomial coefficient in front of $x^2y^2$ is\n"
"in the expansion of $(x+y)^4$; how would I do it? Lean can't ask questions,\n"
"it can only prove theorems! So the way I would ask this is:\n"
"  prove that there exists a real number $c$ such that\n"
"\n"
"  $(x+y)^4 = x^4 + 4x^3y + cx^2y^2 + 4xy^3 + y^4$.\n"
"\n"
"  The way to prove that such a number\n"
"  exists is to exhibit it, that is, tell me which number to *use*,\n"
"  and then prove that that number indeed satisfies the equation.\n"
"\n"
"This is called an *existential statement*. In Lean, as in mathematics,\n"
"existence is written using `‚àÉ` (read: \"there exists\").\n"
"This symbol is called the *existential quantifier*, and is written in Lean by typing \\exists, that is, a backslash, then the word `exists`, and then a space.\n"
"So this goal would look in Lean like so:\n"
"\n"
"`‚àÉ (c : ‚Ñù), (x + y)^4 = x^4 + 4*x^3*y + c*x^2*y^2 + 4*x*y^3 + y^4`\n"
"\n"
"To prove an existence statement, you need to provide a specific value that works. This is where the `use` tactic comes in.\n"
"\n"
"If you think you know what value of `c` would work, you can write `use 42` (or with `42` replaced by whatever number you think is right). Lean will then substitute that value and ask you to prove that the resulting equation is true.\n"
"\n"
"Try writing `use`, then a space, and then a number. Do you see what to do after that?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "If we know that $x = 2$, then we can prove that $x + y = 2 + y$."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "The `have` tactic has the following\n"
"syntax: `have NewHypothesisName (Assumptions) : Claim := by GiveTheProof`.\n"
"This creates a new hypothesis called\n"
"`NewHypothesisName : ‚àÄ (Assumptions), ClaimHolds`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "# Using universal statements\n"
"\n"
"Now let's learn the flip side of `intro`. You have already learned that:\n"
"- if you have `‚àÉ` in the goal, you write `use` to provide a specific value. And\n"
"- if you have `‚àÄ` in the goal, you write `intro` to introduce an arbitrary variable\n"
"\n"
"But what if you have `‚àÄ` in a *hypothesis* and you want to use it for a particular value?\n"
"\n"
"For a concrete example, suppose you have:\n"
"- A positive real number `t`; that is, a real number `t`, together with a hypothesis, say, `t_pos` that `t > 0`\n"
"- A function `f : ‚Ñù ‚Üí ‚Ñù`\n"
"- A hypothesis `hf : ‚àÄ x > 0, f (x) = x^2`, meaning \"for all x positive, f (x) equals x¬≤\". (Note that you *have* to put a space after `f` before `(x)` or else Lean will be very angry with you! In fact, Lean will often drop unnecessary parentheses, so you'll see `f x` instead of `f (x)` -- and again, definitely *not* `f(x)`.)\n"
"- And you want to prove the goal `f (t) = t^2`.\n"
"\n"
"Can you use `apply hf`? No! The hypothesis `hf` says \"for all positive x, f (x) = x¬≤\" but the goal asks specifically about `f (t) = t¬≤`. They're not  the same.\n"
"\n"
"This is where the `specialize` command comes in. You can write `specialize hf t` to specialize the statement `hf` to the particular value `t`. This transforms `hf` from \"‚àÄ x > 0, f (x) = x¬≤\" into \"t > 0 ‚Üí f (t) = t¬≤\". Just like we had to `intro` multiple times (once for the dummy variable name, and again to name the hypothesis), we can specialize multiple times; so you can now write `specialize hf t_pos`. Or you can kill two birds with one stone via: `specialize hf t t_pos`.\n"
"\n"
"I'm sure you can solve the goal from there yourself!"
msgstr ""

#: Game.Levels.L2Pset.L2Pset2
msgid "Prove that the product of two convergent sequences converges to the product of their limits."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Excellent! You've learned the `rfl` tactic.\n"
"\n"
"The key difference:\n"
"- Use `apply hypothesis_name` when you have a hypothesis that matches your goal\n"
"- Use `rfl` when you need to prove that something equals itself\n"
"\n"
"These are two of the most fundamental tactics in Lean. As we progress through real analysis, you'll see that many complex proofs ultimately come down to showing that two expressions are identical."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "# Level 2: Doubling Convergence\n"
"\n"
"After conquering the constant sequence, let's up our game: if a sequence converges, then doubling that sequence also converges, and converges to double the original limit.\n"
"\n"
"## The Factory Scaling Challenge\n"
"\n"
"Imagine our Machinist receives a challenge from the Engineer: 'Please double all the lengths, but maintain the same quality standards.' How should the Machinist respond?\n"
"\n"
"If the Engineer demands the doubled lengths be within $\\varepsilon$ of $2L$, the Machinist can't just demand that the original process meet the original tolerance $\\varepsilon$, because\n"
"\n"
"`|2 * a (n) - 2 * L| < 2 * Œµ`,\n"
"\n"
"not `Œµ`. Instead, we must be more clever. Can you think of what to do?\n"
"\n"
"That's right, the `Œµ` in the original process\n"
"is *arbitrary*, so we can play with it!\n"
"If we could get the original process can guarantee output within $\\varepsilon/2$ of $L$, then doubling that output will be within $\\varepsilon$ of $2L$.\n"
"\n"
"This is the key insight: **when scaling by a constant, we need to scale our tolerance demands inversely**.\n"
"\n"
"## The Mathematical Setup\n"
"\n"
"Suppose we have:\n"
"- A sequence $a : \\mathbb{N} \\to \\mathbb{R}$ that converges to $L$\n"
"- A sequence $b : \\mathbb{N} \\to \\mathbb{R}$ with the property that $b(n) = 2 \\cdot a(n)$ for all $n$\n"
"\n"
"We want to prove that $b$ converges to $2 \\cdot L$.\n"
"\n"
"## Key Insight: Inverse Tolerance Scaling\n"
"\n"
"The crucial observation is that:\n"
"\n"
"$|b(n) - 2L| = |2 \\cdot a(n) - 2L| = 2 \\cdot |a(n) - L|$\n"
"\n"
"So if we want $|b(n) - 2L| < \\varepsilon$, we need $2 \\cdot |a(n) - L| < \\varepsilon$, which means $|a(n) - L| < \\varepsilon/2$.\n"
"\n"
"This is exactly what we can get from the convergence of $a$!\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"**Absolute Value of Products**:\n"
"You'll need the new theorem `abs_mul` which states that for any real numbers $x$ and $y$:\n"
"\n"
"$|x \\cdot y| = |x| \\cdot |y|$.\n"
"\n"
"To use this theorem, you may find it convenient to\n"
"make a new hypothesis using `have` and then `rewrite` by that hypothesis. That is, you can say,\n"
"\n"
"`have NewFact : |Something * SomethingElse| =\n"
"|Something| * |SomethingElse| :=\n"
"by apply abs_mul`\n"
"\n"
"and then `rewrite [NewFact]` will replace `|Something * SomethingElse|` by `|Something| * |SomethingElse|` (either at the Goal, or `at` a hypothesis, if you so specify).\n"
"\n"
"**Arithmetic with inequalities**: You might also find the `linarith` tactic helpful. It is a very powerful tactic like `ring_nf`, but instead of proving algebraic *identities*, it proves *inequalities* involving \"linear arithmetic\" on the specified hypotheses. For example,\n"
"if you have as hypotheses: `h‚ÇÅ : X ‚â§ Y`, `h‚ÇÇ : 2 * Y ‚â§ Z`,\n"
"and your Goal is to prove that `2 * X ‚â§ Z`, then\n"
"simply calling `linarith [h‚ÇÅ, h‚ÇÇ]` will do the trick.\n"
"\n"
"## Your Strategic Approach\n"
"\n"
"1. Unfold the definition of convergence for the goal\n"
"2. Given any $\\varepsilon > 0$, use the convergence of $a$ with tolerance $\\varepsilon/2$. You may find it useful to separately prove the inequality `0 < Œµ / 2` -- which\n"
"tactic do you think will help with that?\n"
"3. Extract the witness $N$ from the convergence of $a$\n"
"4. Use the same $N$ for your sequence $b$\n"
"5. Apply the scaling hypothesis and use `abs_mul` to relate $|b(n) - 2L|$ to $|a(n) - L|$\n"
"6. Use the convergence bound for $a$ to conclude\n"
"\n"
"## Why This Pattern Matters\n"
"\n"
"This proof introduces the important technique of **inverse scaling** for tolerances. When you scale a sequence by a constant $c$, you need to scale your tolerance demands by $1/c$. This principle will appear again when you study:\n"
"- Products of sequences (where both factors contribute to the error)\n"
"- Derivatives (where the limit definition involves scaling by $h$)\n"
"- Integration (where Riemann sums involve scaling by partition widths)\n"
"\n"
"The ability to manage how constants affect convergence is fundamental to all of analysis!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L02_DoubleSeqConv
msgid "Also try unfolding the definition in `h`: `change ‚àÄ Œµ‚ÇÅ > 0, ‚àÉ N‚ÇÅ : ‚Ñï, ‚àÄ n ‚â• N‚ÇÅ, |a n - L| < Œµ‚ÇÅ at h`"
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "Problem 5"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Perfect! You've learned the `use` tactic for existence proofs.\n"
"\n"
"Notice what happened:\n"
"1. `use 6` told Lean that $c = 6$ is our proposed value\n"
"2. The goal changed to proving $(x + y)^4 = x^4 + 4x^3y + 6x^2y^2 + 4xy^3 + y^4$\n"
"3. `ring_nf` verified that this algebraic identity is correct\n"
"\n"
"The `use` tactic is fundamental in real analysis. You'll need it to:\n"
"- Find specific values of $\\varepsilon$ and $\\delta$ in limit proofs\n"
"- Construct witnesses for existence theorems\n"
"- Provide counterexamples\n"
"\n"
"Your growing toolkit:\n"
"- `apply`, `rfl`, `rewrite` for basic equality reasoning\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for existence proofs"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L03_SumOfSeqs
msgid "For any real numbers `x` and `y`, we have `|x + y| ‚â§ |x| + |y|`."
msgstr ""
